require 'rails_helper'

RSpec.describe "Messages", type: :request do

  before do
    @chat_app = FactoryBot.create(:chat_application)
    @chat = FactoryBot.create(:chat, chat_id: 1, chat_application: @chat_app)
    BASE_URL = "/api/v1/applications/#{@chat_app.token}/chats/#{@chat.chat_id}/messages"
  end

  before do
    Message.__elasticsearch__.create_index! force: true
  end

  describe "GET /" do
    it "returns http success with no data" do
      get "#{BASE_URL}/"
      expect(response).to have_http_status(:ok)
      data = JSON.parse(response.body)
      expect(data['status']).to eq('success')
      expect(data['data'].length).to eq(0)
    end

    it "returns http success with data" do
      message = FactoryBot.create(:message, chat: @chat).as_json

      get "#{BASE_URL}/"
      expect(response).to have_http_status(:ok)
      data = JSON.parse(response.body)
      expect(data['status']).to eq('success')
      expect(data['data'].length).to eq(1)
      expect(data['data'].first['text']).to eq(message['text'])
      expect(data['data'].first['message_id']).to eq(message['message_id'])
    end
  end

  describe "GET /:message_id" do
    it "returns http success with data" do
      message = FactoryBot.create(:message, chat: @chat).as_json
      get "#{BASE_URL}/#{message['message_id']}"
      expect(response).to have_http_status(:ok)
      data = JSON.parse(response.body)
      expect(data['status']).to eq('success')
      expect(data['data']['content']).to eq(message['content'])
      expect(data['data']['message_id']).to eq(message['message_id'])
    end

    it "returns http error not found" do
      get "#{BASE_URL}/invalid_message_id"
      expect(response).to have_http_status(:not_found)
      data = JSON.parse(response.body)
      expect(data['status']).to eq('error')
    end

  end

  describe 'GET /?q=...' do
    before do
      @messages = %w[msg_1 msg_2 msg_3 hi_1 hi_2 hi_3].sort
      @messages.each do |msg|
        FactoryBot.create(:message, chat: @chat, content: msg)
      end
    end

    it "returns http success with all data when no search query" do
      get "#{BASE_URL}/?q="
      expect(response).to have_http_status(:ok)
      data = JSON.parse(response.body)
      expect(data['status']).to eq('success')
      messages = data['data'].sort_by { |m| m['content'] }.map { |m| m['content'] }
      expect(messages).to eq(@messages)
    end

    it "returns http success with filtered data when search query" do
      %w[hi msg 1 _].each do |query|
        expected_messages = @messages.grep(/#{query}/).sort

        get "#{BASE_URL}/?q=#{query}"
        expect(response).to have_http_status(:ok)
        data = JSON.parse(response.body)
        expect(data['status']).to eq('success')
        messages = data['data'].sort_by { |m| m['content'] }.map { |m| m['content'] }
        expect(messages).to eq(expected_messages)
      end
    end

  end

  describe "POST /" do
    it "returns http success" do
      message = FactoryBot.build(:message, chat: @chat, message_id: -1 ).as_json
      post "#{BASE_URL}/", params: message
      expect(response).to have_http_status(:created)
      data = JSON.parse(response.body)
      expect(data['status']).to eq('success')
      expect(data['data']['content']).to eq(message['content'])
      expect(data['data']['message_id']).to eq(1) # message id is generated by the server even if it is provided
      expect(data['data']['message_id']).to_not eq(message['message_id'])
    end

    it "returns http error with invalid data" do
      message = FactoryBot.build(:message, chat: @chat).as_json
      message.delete('content')
      post "#{BASE_URL}/", params: message
      expect(response).to have_http_status(:bad_request)
      data = JSON.parse(response.body)
      expect(data['status']).to eq('error')
    end

    it "returns message_id = 1 when it is the first message in another chat" do
      message1 = FactoryBot.build(:message, chat: @chat).as_json
      post "#{BASE_URL}/", params: message1
      data1 = JSON.parse(response.body)['data']
      expect(data1['message_id']).to eq(1)

      chat2 = FactoryBot.create(:chat, chat_id: 2, chat_application: @chat_app)
      message2 = FactoryBot.build(:message, chat: chat2).as_json
      BASE_URL2 = "/api/v1/applications/#{@chat_app.token}/chats/#{chat2['chat_id']}/messages"
      post "#{BASE_URL2}/", params: message2
      data2 = JSON.parse(response.body)['data']
      expect(data2['message_id']).to eq(1)

      expect(message1).to_not eq(message2)
      expect(@chat).to_not eq(chat2)
    end

  end

  describe "PATCH /:message_id" do
    it "returns http success with data" do
      message = FactoryBot.create(:message, chat: @chat).as_json
      new_content = 'new content'
      message['content'] = new_content
      patch "#{BASE_URL}/#{message['message_id']}", params: message
      expect(response).to have_http_status(:ok)
      data = JSON.parse(response.body)
      expect(data['status']).to eq('success')
      expect(data['data']['content']).to eq(new_content)
    end

    it "returns http error with invalid data" do
      message = FactoryBot.create(:message, chat: @chat).as_json
      message.delete('content')
      patch "#{BASE_URL}/#{message['message_id']}", params: message
      expect(response).to have_http_status(:bad_request)
      data = JSON.parse(response.body)
      expect(data['status']).to eq('error')
    end

    it "returns http error not found" do
      message = FactoryBot.create(:message, chat: @chat).as_json
      patch "#{BASE_URL}/invalid_message_id", params: message
      expect(response).to have_http_status(:not_found)
      data = JSON.parse(response.body)
      expect(data['status']).to eq('error')
    end

  end

  describe "DELETE /:message_id" do
    it "returns http success with data" do
      message = FactoryBot.create(:message, chat: @chat).as_json

      expect { delete "#{BASE_URL}/#{message['message_id']}" }
      .to not_change { ChatApplication.count }
      .and not_change { Chat.count }

      expect(response).to have_http_status(:ok)
      data = JSON.parse(response.body)
      expect(data['status']).to eq('success')
    end

    it "returns http error not found" do
      delete "#{BASE_URL}/invalid_message_id"
      expect(response).to have_http_status(:not_found)
      data = JSON.parse(response.body)
      expect(data['status']).to eq('error')
    end

  end

end
